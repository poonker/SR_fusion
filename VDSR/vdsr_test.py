# -*- coding: utf-8 -*-
"""vdsr_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cNdKyoRpB2aQl-bDuesxJFzwtdy6t5Ml
"""

# Commented out IPython magic to ensure Python compatibility.
# Load the package you are going to use
import torch
from torch.autograd import Variable
from PIL import Image
import numpy as np
import time, math
import matplotlib.pyplot as plt
import argparse, os
from torch.autograd import Variable
import numpy as np
import time, math, glob
import scipy.io as sio
from torch import nn
import cv2 
#from torchvision.transforms import ToTensor, ToPILImage
#import torch.nn.functional as F
# %matplotlib inline

# Load the pretrained model
#model = torch.load("model/model_epoch_50.pth")["model"]

parser = argparse.ArgumentParser(description="PyTorch VDSR Eval")
parser.add_argument("--cuda", action="store_true", help="use cuda?")
parser.add_argument("--model", default="model/model_epoch_50.pth", type=str, help="model path")
parser.add_argument("--testset", default="../test_image", type=str, help="testset path, ")
parser.add_argument("--gpus", default="0", type=str, help="gpu ids (default: 0)")
parser.add_argument("--save_dir", default="../test_result", type=str, help="gpu ids (default: 0)")
opt = parser.parse_args()
# Here is the function for PSNR calculation
def PSNR(pred, gt, shave_border=0):
    height, width = pred.shape[:2]
    pred = pred[shave_border:height - shave_border, shave_border:width - shave_border]
    gt = gt[shave_border:height - shave_border, shave_border:width - shave_border]
    imdff = pred - gt
    rmse = math.sqrt(np.mean(imdff ** 2))
    if rmse == 0:
        return 100
    return 20 * math.log10(255.0 / rmse)

# Define the colorization function
# We'll reuse the Cb and Cr channels from bicubic interpolation
def colorize(y, ycbcr): 
    img = np.zeros((y.shape[0], y.shape[1], 3), np.uint8)
    img[:,:,0] = y
    img[:,:,1] = ycbcr[:,:,1]
    img[:,:,2] = ycbcr[:,:,2]
    img = Image.fromarray(img, "YCbCr").convert("RGB")
    return img

# Load the groundtruth image and the low-resolution image (downscaled with a factor of 4)
#im_gt = Image.open().convert("RGB")
#im_b = Image.open("Set5/butterfly_GT_scale_4.bmp").convert("RGB")

#image_list = glob.glob(opt.dataset+"_mat/*.*") 
image_list = glob.glob(opt.testset+"/*.*")
#未设置scalefactor 
for image_name in image_list:
  im_gt = Image.open(image_name).convert("RGB")
  #im_b = Image.open("Set5/butterfly_GT_scale_4.bmp").convert("RGB")
  #result = F.interpolate(input, scale_factor=2, mode='nearest')
  im_gt_array = np.asarray(im_gt)
  size = (im_gt.width,im_gt.height)
  #im_b = F.interpolate(im_gt_tensor, scale_factor=4, mode='bicubic') #4倍bicubic放缩
  im_b = cv2.resize(im_gt_array, dsize = (size[1]* 4, size[0] * 4), interpolation = cv2.INTER_CUBIC)

  # Convert the images into YCbCr mode and extraction the Y channel (for PSNR calculation)
  im_gt_ycbcr = np.array(im_gt.convert("YCbCr"))
  #img = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)
  #im_b_ycbcr = np.array(im_b.convert("YCbCr"))
  im_b_ycbcr = np.array(cv2.cvtColor(im_b, cv2.COLOR_BGR2YCR_CB))
  im_gt_y = im_gt_ycbcr[:,:,0].astype(float)
  im_b_y = im_b_ycbcr[:,:,0].astype(float)

  # Prepare for the input, a pytorch tensor
  im_input = im_b_y/255.
  im_input = Variable(torch.from_numpy(im_input).float()).\
    view(1, -1, im_input.shape[0], im_input.shape[1])

  # Let's try the network feedforward in cpu mode
  model = torch.load(opt.model, map_location=lambda storage, loc: storage)["model"]
  #model = model.cpu()
  print('**********************************')
  # Let's see how long does it take for processing
  start_time = time.time()
  out = model(im_input)
  elapsed_time = time.time() - start_time
  #print("It takes {}s for processing in cpu mode".format(elapsed_time))
  
  # Get the output image
  out = out.cpu()
  im_h_y = out.data[0].numpy().astype(np.float32)
  im_h_y = im_h_y * 255.
  im_h_y[im_h_y < 0] = 0
  im_h_y[im_h_y > 255.] = 255.
  im_h_y = im_h_y[0,:,:]

  print('**********************************')
  # Calculate the PNSR for vdsr prediction
  psnr_predicted = PSNR(im_gt_y, im_h_y)
  print('psnr for vdsr is {}dB'.format(psnr_predicted))

  # Colorize the grey-level image and convert into RGB mode
  im_h = colorize(im_h_y, im_b_ycbcr)
  im_gt = Image.fromarray(im_gt_ycbcr, "YCbCr").convert("RGB")
  im_b = Image.fromarray(im_b_ycbcr, "YCbCr").convert("RGB")

  os.makedirs(opt.save_dir+'/vdsr',exist_ok=True)
  im_h.save(opt.save_dir+'/vdsr/vdsr.bmp')
  print('complete.')